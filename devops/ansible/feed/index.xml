<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	 xmlns:media="http://search.yahoo.com/mrss/" >

<channel>
	<title>Ansible &#8211; A DevOps Blog</title>
	<atom:link href="https://www.valewood.org/devops/ansible/feed/" rel="self" type="application/rss+xml" />
	<link>https://www.valewood.org/</link>
	<description>Occasionally a developer makes an Ops!</description>
	<lastBuildDate>Wed, 26 Oct 2022 03:28:57 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.0.2</generator>

<image>
	<url>https://www.valewood.org/wp-content/uploads/2022/08/A-DevOoops-1-e1660773390219.png</url>
	<title>Ansible &#8211; A DevOps Blog</title>
	<link>https://www.valewood.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>How To Create ESXi VM With Ansible</title>
		<link>https://www.valewood.org/ansible-create-vmware-esxi-vm/</link>
		
		<dc:creator><![CDATA[Geoff Wagner]]></dc:creator>
		<pubDate>Wed, 26 Oct 2022 03:28:55 +0000</pubDate>
				<category><![CDATA[DevOps]]></category>
		<category><![CDATA[Ansible]]></category>
		<guid isPermaLink="false">/?p=1213</guid>

					<description><![CDATA[This post will help anyone who is attempting to use Ansible to create new VMs with automation when Practicing DevOps. I use this in my home lab to help stay current with new trends in DevOps. Not everyone is going&#8230;]]></description>
										<content:encoded><![CDATA[
<p>This post will help anyone who is attempting to use <a href="https://www.ansible.com/" data-internallinksmanager029f6b8e52c="7" title="Ansible">Ansible</a> to create new VMs with automation when <a href="https://www.valewood.org/practicing-devops/" data-type="post" data-id="14">Practicing DevOps</a>.  I use this in my home lab to help stay current with new trends in <a href="https://www.valewood.org/topics/devops/" data-internallinksmanager029f6b8e52c="15" title="Demystifying the DevOps Methodology and How You Can Leverage it for Success!​" target="_blank" rel="noopener">DevOps</a>.  Not everyone is going to be fortunate enough to have cloud playgrounds to test out new things, and home labs are a great way to make a one-time investment in your future.</p>



<p>The code for the project can be found <a href="https://github.com/gwagner/ansible-examples/tree/main/create-vmware-esxi-vm" data-type="URL" data-id="https://github.com/gwagner/ansible-examples/tree/main/create-vmware-esxi-vm" target="_blank" rel="noopener">here</a>!</p>



<h2>Prerequisites</h2>



<p>This article is going to assume that you already have VMWare running in a home lab somewhere.  This also assumes that you have some familiarity with VMware and networking.</p>



<p>This post will also assume that you have already installed a baseline OS.  <a href="https://www.packer.io/" data-internallinksmanager029f6b8e52c="17" title="Packer" target="_blank" rel="noopener">Packer</a> is a good tool to use to automate your baseline operating system installation to create a reusable disk image.</p>



<h2>The Playbook</h2>



<p>Below is the full code to deploy a virtual machine from a disk image.  </p>



<p>The general idea is to run <code>ansible-playbook create-vmware-esxi-vm.yaml -i inventory.yaml</code> from your command line.  The playbook will then check to see if a machine exists.  If set to destructive, it will then delete any machine with the same name, copy an existing disk image, set some machine specifics like IP address, and then power on your machine.</p>



<p>VMWare vSphere makes this a fairly novel activity via the use of templates.  A standalone ESXi node does not have the benefit of templates which is why things get a bit more complex in this space.</p>



<p>A majority of this playbook is also setup with <code>deletage_to: localhost</code>.  This means that the computer running the ansible script will also execute anything with the defined <code>deletage_to: localhost</code>.  The remote machine from inventory does not yet exist, which means; if <code>deletage_to: localhost</code> was not set, you would immediately receive an ansible connection error.</p>



<pre class="wp-block-code yaml"><code>---
- name: Create VMWare ESXi VM
  hosts: all
  gather_facts: false
  vars:
    destructive: false
  tasks:
    - include_vars: config.yaml
      delegate_to: localhost

    - include_vars: creds.yaml # Remember, this should be in a vault
      delegate_to: localhost   # These creds are for example use only

    - name: Check if virtual machine exists
      community.vmware.vmware_guest_info:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        datacenter: "ha-datacenter"
        name: "{{ vmware.name }}"
      delegate_to: localhost
      ignore_errors: true
      throttle: 1
      register: vmware_validate_guest
      when: destructive is not defined or not destructive

    - set_fact:
        destructive: yes
      when: |
        vmware_validate_guest is defined and (
          (vmware_validate_guest.skipped is defined and not vmware_validate_guest.skipped) 
          or (vmware_validate_guest.failed is defined and vmware_validate_guest.failed == True)
        )

    - name: Add vmware as a host
      add_host:
        hostname: "{{ vmware_host }}"
        ansible_ssh_host: "{{ vmware_host }}"
        ansible_user: "{{ vmware_user }}"
        ansible_ssh_pass: "{{ vmware_password }}"
      when: destructive

    - set_fact:
        num_cpu_cores_per_socket: "{{ vmware.num_cpus | int / 2 }}"

    - name: Remove virtual machine from inventory
      community.vmware.vmware_guest:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        name: "{{ vmware.name }}"
        state: absent
        force: True
      delegate_to: localhost
      throttle: 1
      when: destructive

    - name: Delete VM Folders
      ansible.builtin.file:
        path: "{{storage_path}}/{{ vmware.name }}/"
        state: absent
      delegate_to: "{{ vmware_host }}"
      when: destructive
      throttle: 5

    - name: Create a virtual machine on vmware
      community.vmware.vmware_guest:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        folder: /vm/
        name: "{{ vmware.name }}"
        state: poweredoff
        guest_id: "{{ vmware.guest_id }}"    
        disk: "{{ vmware.disks }}"
        datastore: "{{ datastore_name }}"
        hardware:
          boot_firmware: efi
          memory_mb: "{{ vmware.memory_mb }}"
          num_cpus: "{{ vmware.num_cpus }}"
          num_cpu_cores_per_socket: "{{ num_cpu_cores_per_socket | int }}"
          scsi: paravirtual
        networks:
        - name: "{{ vmware.port_group }}"
          connect: yes
          mac: "{{ vmware.mac_address  }}"
          ip: "{{ vmware.ip_address }}"
          netmask: "{{ vmware.netmask }}"
          device_type: vmxnet3
          type: static
      delegate_to: localhost
      register: deploy_vm
      throttle: 5
      when: destructive

    - name: Copy boot disk VMDK Files
      ansible.builtin.command: "{{ item }}"
      delegate_to: "{{ vmware_host }}"
      loop:
        - vmkfstools -i "{{storage_path}}/{{ image_name }}/{{ image_name }}.vmdk" "{{storage_path}}/{{ vmware.name }}/{{ image_name }}.vmdk" -d thin
      when: destructive
      throttle: 3

    - name: Add boot disks to virtual machine
      community.vmware.vmware_guest_disk:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        name: "{{ vmware.name }}"
        datacenter: ha-datacenter
        disk:
          - filename: "&#91;{{datastore_name}}] {{ vmware.name }}/{{ image_name }}.vmdk"
            scsi_type: 'paravirtual'
            scsi_controller: 0
            unit_number: 1
      delegate_to: localhost
      register: disk_facts
      when: destructive
      throttle: 5

    - name: Power on virtual machine
      community.vmware.vmware_guest:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        name: "{{ vmware.name }}"
        state: poweredon
        wait_for_ip_address: yes
      delegate_to: localhost
      register: deploy_vm
      when: destructive</code></pre>



<h3>Task By Task Breakdown</h3>



<p>First, we should look at the inventory.</p>



<p>This example has only one example host defined in it under a group called example.  You are able to define as many hosts in inventory that you would like.  </p>



<p>The structure of the vars defined under example-01.valewood.lab are there to provide everything the playbook needs in order to provision a server in ESXi.</p>



<pre class="wp-block-code yaml"><code>---
all:
  hosts:
  children:
    example:
      hosts:
        example-01.valewood.lab:
          ip: 192.168.1.10 
          ansible_host: 192.168.1.10
          vmware:
            ip_address: 192.168.1.10
            gateway_address: 192.168.1.1
            dns_address: 192.168.1.1
            netmask: 255.255.255.0
            mac_address: "00:16:3E:A0:06:43"
            memory_mb: 8192
            name: example-01
            num_cpus: 4
            port_group: Example-App
            guest_id: centos64Guest
            disks: &#91;]</code></pre>



<p>Below is the code that reads in configurations and credentials.  These are broken up into 2 different files because credentials should always be encrypted and never stored in plaintext.  </p>



<pre class="wp-block-code yaml"><code>    - include_vars: config.yaml
      delegate_to: localhost

    - include_vars: creds.yaml # Remember, this should be in a vault
      delegate_to: localhost   # These creds are for example use only</code></pre>



<p>The next step is to check to see if a VM exists in VMWare or not with the same name.  This is a crucial step to ensure that duplicate names are not used in VMWare.  Here are some key notes about additional configurations:</p>



<ul><li>validate_certs is set to false because most of us are not going to be using trusted 3rd party certs in our VMware environment.  If you are doing this in a professional environment, ensure you have valid certs installed and leave validate_certs set to the default of true.</li><li>validate_certs should also be set to false if you are connecting to your VMWare server via IP address since your cert will not match an IP address.</li><li>vmware_user and vmware_password should be set to a user that has SSH access to your VMWare server.  I would not recommend that you do this in any sort of production environment, but it is perfectly fine for a home lab.</li><li>datacenter is set to ha-datacenter.  This is the default name of a &#8220;datacenter&#8221; in ESXi.  There is no reason to change this.</li><li>throttle is set to 1 to provide time to ctrl+c IF you happen to run your playbook by mistake against many machines at once.</li><li>destructive is a variable that can be set which tells this playbook to not destroy and rebuild machines if they already exist.  By default, the destructive variable it is not defined which means a check will be performed.</li></ul>



<pre class="wp-block-code"><code>    - name: Check if virtual machine exists
      community.vmware.vmware_guest_info:
        validate_certs: false 
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        datacenter: "ha-datacenter"
        name: "{{ vmware.name }}"
      delegate_to: localhost
      ignore_errors: true
      throttle: 1
      register: vmware_validate_guest
      when: destructive is not defined or not destructive</code></pre>



<p>The next block of code will set the <code>destructive</code> variable to true IF we did the validation check from the previous block.  The validation check in the previous block will not run if <code>destructive</code> is set to true.  This acts as a one-way gate.</p>



<pre class="wp-block-code yaml"><code>    - set_fact:
        destructive: yes
      when: |
        vmware_validate_guest is defined and (
          (vmware_validate_guest.skipped is defined and not vmware_validate_guest.skipped) 
          or (vmware_validate_guest.failed is defined and vmware_validate_guest.failed == True)
        )</code></pre>



<p>Things get a little bit tricky here, but I will explain the rationale behind this next block.  Your inventory file only has virtual machines defined in it, but for ansible remote connections to work properly, a host must be in inventory.  To get around this, in the middle of this playbook run, we call add_host which has an explicit delegate_to statement so that it runs on localhost.</p>



<p>The reason this is tricky is because of the way that ansible does variable expansion.  One would think that a single host is being added to the inventory, but what is really happening in a playbook?  Ansible is expanding variable scope out to each individual machine in the inventory.  This means that add_host is actually being added in the context of each host in the inventory.  If you have 10 hosts defined in inventory, add_host adds variables for your VMWare host for each inventory host.</p>



<p>TLDR; each host in inventory now has the ability to utilize a <code>delegate_to: {{ vmware_host }}</code> statement as part of their tasks.</p>



<pre class="wp-block-code yaml"><code>    - name: Add vmware as a host
      add_host:
        hostname: "{{ vmware_host }}"
        ansible_ssh_host: "{{ vmware_host }}"
        ansible_user: "{{ vmware_user }}"
        ansible_ssh_pass: "{{ vmware_password }}"
      when: destructive</code></pre>



<p>Next, we need to do a little bit of math.  This could be done live through future executions, but I like to split things like this out into separate set_fact tasks to ensure I can easily run any debug tasks in the future.</p>



<p>Basically, this accomplishes telling VMWare that I want my CPU cores evenly distributed across sockets.  This is not perfect because it does not take care of edge cases of 1 CPU or 3 CPUs being defined in inventory.  For my use cases, I never define anything that way, but this could easily be updated to accommodate.</p>



<pre class="wp-block-code yaml"><code>    - set_fact:
        num_cpu_cores_per_socket: "{{ vmware.num_cpus | int / 2 }}"</code></pre>



<p>Next, if we are destructive, we need to delete an existing VM.  I am not going to rehash any of the special variables from above.  The only relevant thing to notice here is the state being set to absent which will delete the machine, and force is set to true which will bypass any safety checks VMWare might do.</p>



<pre class="wp-block-code yaml"><code>    - name: Remove virtual machine from inventory
      community.vmware.vmware_guest:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        name: "{{ vmware.name }}"
        state: absent
        force: True
      delegate_to: localhost
      throttle: 1
      when: destructive</code></pre>



<p>Next is a little bit of cleanliness.  The delete statement above will not actually cleanup the VMWare datastore filesystem.  We are performing a <code>delegate_to: {{ vmware_host }}</code> which means we will be running a direct delete over SSH to your server running vmware.</p>



<pre class="wp-block-code yaml"><code>    - name: Delete VM Folders
      ansible.builtin.file:
        path: "{{storage_path}}/{{ vmware.name }}/"
        state: absent
      delegate_to: "{{ vmware_host }}"
      when: destructive
      throttle: 5</code></pre>



<p>Finally, the meat of the playbook.  This task creates the VM which is defined in the inventory.  I will break down the relevant variables below.</p>



<ul><li>Folder is neccisary for vShpere.  When only running ESXi, this only requires a default value of /vm/.  Most home labs will not need to change this.</li><li>state is set to poweredoff.  You could set this to poweredon but leaving it poweredoff ensures you can do post-processing after this create task.</li></ul>



<p>Please note, <code>Create a virtual machine on vmware</code> is not referencing any kind of existing disk image.  This will create a new completely blank VM.  Subsequent tasks will utilize your disk image to ensure it is properly attached to this machine.</p>



<pre class="wp-block-code yaml"><code>    - name: Create a virtual machine on vmware
      community.vmware.vmware_guest:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        folder: /vm/
        name: "{{ vmware.name }}"
        state: poweredoff
        guest_id: "{{ vmware.guest_id }}"    
        disk: "{{ vmware.disks }}"
        datastore: "{{ datastore_name }}"
        hardware:
          boot_firmware: efi
          memory_mb: "{{ vmware.memory_mb }}"
          num_cpus: "{{ vmware.num_cpus }}"
          num_cpu_cores_per_socket: "{{ num_cpu_cores_per_socket | int }}"
          scsi: paravirtual
        networks:
        - name: "{{ vmware.port_group }}"
          connect: yes
          mac: "{{ vmware.mac_address  }}"
          ip: "{{ vmware.ip_address }}"
          netmask: "{{ vmware.netmask }}"
          device_type: vmxnet3
          type: static
      delegate_to: localhost
      register: deploy_vm
      throttle: 5
      when: destructive</code></pre>



<p>Next, perform a copy of an existing disk image into the folder that was just created for this new virtual machine.  This will essentially perform the same action that vSphere performs when cloning templates.</p>



<p>The key here is to utilize <code>vmkfstools</code> over ssh to ensure that you are able to get a thin provisioned copied disk.  If this is performed directly via ansible modules, you are not able to get a thin disk without vSphere.</p>



<pre class="wp-block-code yaml"><code>    - name: Copy boot disk VMDK Files
      ansible.builtin.command: "{{ item }}"
      delegate_to: "{{ vmware_host }}"
      loop:
        - vmkfstools -i "{{storage_path}}/{{ image_name }}/{{ image_name }}.vmdk" "{{storage_path}}/{{ vmware.name }}/{{ image_name }}.vmdk" -d thin
      when: destructive
      throttle: 3</code></pre>



<p>Next, we need to tell VMWare to mount our cloned disk to the recently created VM.  The new VM will have a scsi_controller so we just need to give it the right controller number of 0, and unit_number 1 to ensure we do not overwrite the new disk created via <code>Create a virtual machine on vmware</code>.</p>



<pre class="wp-block-code yaml"><code>    - name: Add boot disks to virtual machine
      community.vmware.vmware_guest_disk:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        name: "{{ vmware.name }}"
        datacenter: ha-datacenter
        disk:
          - filename: "&#91;{{datastore_name}}] {{ vmware.name }}/{{ image_name }}.vmdk"
            scsi_type: 'paravirtual'
            scsi_controller: 0
            unit_number: 1
      delegate_to: localhost
      register: disk_facts
      when: destructive
      throttle: 5</code></pre>



<p>And finally we tell ESXi to power on the virtual machine.</p>



<pre class="wp-block-code yaml"><code>    - name: Power on virtual machine
      community.vmware.vmware_guest:
        validate_certs: false
        hostname: "{{ vmware_host }}"
        username: "{{ vmware_user }}"
        password: "{{ vmware_password }}"
        name: "{{ vmware.name }}"
        state: poweredon
        wait_for_ip_address: yes
      delegate_to: localhost
      register: deploy_vm
      when: destructive</code></pre>



<h2>Conclusion</h2>



<p>As you can see, with a fairly concise set of steps, you can level up your DevOps automation game by rapidly creating and tearing down virtual machines in your home lab.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Convert Text File to JSON with Ansible</title>
		<link>https://www.valewood.org/ansible-text-to-json/</link>
		
		<dc:creator><![CDATA[Geoff Wagner]]></dc:creator>
		<pubDate>Mon, 24 Oct 2022 23:00:00 +0000</pubDate>
				<category><![CDATA[DevOps]]></category>
		<category><![CDATA[Ansible]]></category>
		<category><![CDATA[ansible]]></category>
		<category><![CDATA[howto]]></category>
		<guid isPermaLink="false">/?p=1187</guid>

					<description><![CDATA[I was looking through Reddit today and saw an interesting question about how to manipulate files with Ansible. I took a few minutes to throw together an example of how to convert a relatively simple file, a list of strings&#8230;]]></description>
										<content:encoded><![CDATA[
<p>I was looking through Reddit today and saw an <a href="https://www.reddit.com/r/ansible/comments/ycgtkg/convert_output_of_file_to_json_using_j2_template/" data-type="URL" data-id="https://www.reddit.com/r/ansible/comments/ycgtkg/convert_output_of_file_to_json_using_j2_template/" target="_blank" rel="noopener">interesting question</a> about how to manipulate files with <a href="https://www.ansible.com/" data-internallinksmanager029f6b8e52c="7" title="Ansible">Ansible</a>.  I took a few minutes to throw together <a href="https://github.com/gwagner/ansible-examples/tree/main/read-file-output-json" data-type="URL" data-id="https://github.com/gwagner/ansible-examples/tree/main/read-file-output-json" target="_blank" rel="noopener">an example </a>of how to convert a relatively simple file, a list of strings broken up by new lines, and output it as JSON.  </p>



<p>Doing file conversions or data munging is an important skill to learn when growing in a <a href="https://www.valewood.org/topics/devops/" data-internallinksmanager029f6b8e52c="15" title="Demystifying the DevOps Methodology and How You Can Leverage it for Success!​" target="_blank" rel="noopener">DevOps</a> position.  While this is a fairly basic example, utilize this as a stepping stone to understanding more complex data structures.</p>


<p>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-7120242057450442"
     data-ad-slot="6094810801"></ins>
</p>



<h2>Simple Text to JSON Conversion with Ansible</h2>



<p>Below is the Ansible code to read in a file name input.txt delimited by newline characters and then do a simple conversion to JSON writing to output.json.</p>



<pre class="wp-block-code yaml"><code>- name: Simple Read file and output JSON
  hosts: localhost
  connection: local 
  become: false
  tasks:
  - name: Read Data File
    set_fact:
      data: "{{lookup('ansible.builtin.file', './input.txt').split('\n')}}"

  - name: Show debug data
    ansible.builtin.debug: var=data

  - name: Write output json file
    copy:
      dest: output.json
      content: "{{ data | to_json }}" </code></pre>



<h3>Task By Task Breakdown</h3>



<p>The first task reads the input.txt file into a data variable that Ansible can use. It also splits the file into a list via the \n (newline) character.</p>



<pre class="wp-block-code yaml"><code>  - name: Read Data File
    set_fact:
      data: "{{lookup('ansible.builtin.file', './input.txt').split('\n')}}"</code></pre>



<p>set_fact can be one of your best friends in Ansible. It allows you to take either data from what you have available in your playbook run, or lookup data and set it to a useable var for future tasks.  Here I am calling lookup to read an input.txt file and saving it to a data var.</p>



<pre class="wp-block-code yaml"><code>  - name: Show debug data
    ansible.builtin.debug: var=data</code></pre>



<p>ansible.builtin.debug lets you output the values of variables to the terminal during a playbook run.  This code should not be utilized anywhere except for testing.</p>



<pre class="wp-block-code yaml"><code>  - name: Write output json file
    copy:
      dest: output.json
      content: "{{ data | to_json }}" </code></pre>



<p>Finally, utilizing the built-in copy module, you can feed it a variable, like data, and then pipe that to a to_json jinja2 function which will then write your file out to dest.</p>



<p>The result of running this playbook will look something like this:</p>



<pre class="wp-block-code json"><code>&#091;"/site/foo/", "/site/bar/"]</code></pre>


<p>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-7120242057450442"
     data-ad-slot="6094810801"></ins>
</p>



<h2>Complex Text to JSON Conversion with Ansible</h2>



<p>Below is the Ansible code to read in a file name input.txt delimited by newline characters.  After reading the file, a new variable is initialized name data_elements.  A loop is then run to create new dictionary objects with a key of &#8216;name&#8217; and a value of each line of input.txt.  Finally, a copy is run to write the data to disk under output.json.  </p>



<pre class="wp-block-code yaml"><code>- name: Complex Read file and output JSON
  hosts: localhost
  connection: local 
  become: false
  tasks:
  - name: Read Data File
    set_fact:
      data: "{{lookup('ansible.builtin.file', './input.txt').split('\n')}}"

  - name: Show debug data
    ansible.builtin.debug: var=data

  - name: Create a new array
    set_fact: 
      data_elements: &#091;]

  - name: Loop through lines and add data elements to array
    set_fact:
      data_elements: "{{ data_elements + &#091;{'name': item}] }}"
    loop: "{{ data }}"

  - name: Show debug data
    ansible.builtin.debug: var=data_elements

  - name: Write output json file
    copy:
      dest: output.json
      content: "{{ {'records': data_elements} | to_json }}" 
</code></pre>



<h3>Task By Task Breakdown</h3>



<p>Since most of the code here is the same, I will only focus on breaking out the differences.</p>



<pre class="wp-block-code yaml"><code> - name: Create a new array
    set_fact: 
      data_elements: &#091;]</code></pre>



<p>The block above sets up the empty data_elements array that we will utilize to map our file lines onto.</p>



<pre class="wp-block-code yaml"><code>  - name: Loop through lines and add data elements to array
    set_fact:
      data_elements: "{{ data_elements + &#091;{'name': item}] }}"
    loop: "{{ data }}"</code></pre>



<p>This is setting up a loop to loop over our initial data variable which was read from input.txt.  It is appending new dictionaries into a larger array with a key of &#8216;name&#8217; and a value of the item in a loop.</p>



<pre class="wp-block-code yaml"><code>  - name: Write output json file
    copy:
      dest: output.json
      content: "{{ {'records': data_elements} | to_json }}" </code></pre>



<p>Finally, we are doing the same write operation as the simple example, but this time we are creating a dictionary with a key of &#8216;records&#8217; and a value of the data_elements array.</p>



<p>This will have an output that looks like this:</p>



<pre class="wp-block-code json"><code>{
   "records":&#091;
      {
         "name":"/site/foo/"
      },
      {
         "name":"/site/bar/"
      }
   ]
}</code></pre>



<h2>Conclusion</h2>



<p>As I stated at the beginning of the article, data manipulation in DevOps is a key skill to learn.  Hopefully, this helps kickstart someone on their journey into becoming a DevOps engineer!.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
